// This file was auto-generated by Fern from our API Definition.

import * as BasisTheory from "../../../src/api/index";
import { BasisTheoryClient } from "../../../src/Client";
import { mockServerPool } from "../../mock-server/MockServerPool";

describe("Events", () => {
    test("list (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new BasisTheoryClient({ apiKey: "test", correlationId: "test", environment: server.baseUrl });

        const rawResponseBody = [
            "3ds.session.authenticated",
            "3ds.session.challenge-result-retrieved",
            "3ds.session.created",
            "3ds.session.updated",
            "3ds.session.decoupled-challenge-notification",
            "3ds.session.method-completed",
            "3ds.session.challenge-completed",
            "account-updater.job.completed",
            "account-updater.job.created",
            "account-updater.job.failed",
            "apple-pay.created",
            "apple-pay.retrieved",
            "apple-pay.unlinked",
            "apple-pay.updated",
            "application.created",
            "application.updated",
            "application.deleted",
            "application.key.created",
            "application.key.deleted",
            "document.deleted",
            "document.read",
            "document.revealed",
            "document.upload-completed",
            "google-pay.created",
            "google-pay.retrieved",
            "http.request",
            "network-token.created",
            "network-token.cryptogram.created",
            "network-token.deleted",
            "network-token.updated",
            "proxy.created",
            "proxy.deleted",
            "proxy.invoked",
            "proxy.updated",
            "reactor.completed",
            "reactor.created",
            "reactor.deleted",
            "reactor.failed",
            "reactor.invoked",
            "reactor.updated",
            "session.authorized",
            "session.created",
            "tenant.created",
            "tenant.updated",
            "tenant.deleted",
            "tenant.invitation.accepted",
            "tenant.invitation.created",
            "tenant.invitation.deleted",
            "tenant.invitation.resent",
            "tenant.member.created",
            "tenant.member.deleted",
            "token.bank-account.verified",
            "token.created",
            "token.deleted",
            "token.expired",
            "token.property.expired",
            "token.read",
            "token.updated",
            "token-intent.created",
            "token-intent.converted",
            "token-intent.deleted",
        ];
        server
            .mockEndpoint()
            .get("/webhooks/event-types")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.webhooks.events.list();
        expect(response).toEqual([
            "3ds.session.authenticated",
            "3ds.session.challenge-result-retrieved",
            "3ds.session.created",
            "3ds.session.updated",
            "3ds.session.decoupled-challenge-notification",
            "3ds.session.method-completed",
            "3ds.session.challenge-completed",
            "account-updater.job.completed",
            "account-updater.job.created",
            "account-updater.job.failed",
            "apple-pay.created",
            "apple-pay.retrieved",
            "apple-pay.unlinked",
            "apple-pay.updated",
            "application.created",
            "application.updated",
            "application.deleted",
            "application.key.created",
            "application.key.deleted",
            "document.deleted",
            "document.read",
            "document.revealed",
            "document.upload-completed",
            "google-pay.created",
            "google-pay.retrieved",
            "http.request",
            "network-token.created",
            "network-token.cryptogram.created",
            "network-token.deleted",
            "network-token.updated",
            "proxy.created",
            "proxy.deleted",
            "proxy.invoked",
            "proxy.updated",
            "reactor.completed",
            "reactor.created",
            "reactor.deleted",
            "reactor.failed",
            "reactor.invoked",
            "reactor.updated",
            "session.authorized",
            "session.created",
            "tenant.created",
            "tenant.updated",
            "tenant.deleted",
            "tenant.invitation.accepted",
            "tenant.invitation.created",
            "tenant.invitation.deleted",
            "tenant.invitation.resent",
            "tenant.member.created",
            "tenant.member.deleted",
            "token.bank-account.verified",
            "token.created",
            "token.deleted",
            "token.expired",
            "token.property.expired",
            "token.read",
            "token.updated",
            "token-intent.created",
            "token-intent.converted",
            "token-intent.deleted",
        ]);
    });

    test("list (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new BasisTheoryClient({ apiKey: "test", correlationId: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/webhooks/event-types")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.webhooks.events.list();
        }).rejects.toThrow(BasisTheory.UnauthorizedError);
    });

    test("list (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new BasisTheoryClient({ apiKey: "test", correlationId: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/webhooks/event-types")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.webhooks.events.list();
        }).rejects.toThrow(BasisTheory.ForbiddenError);
    });
});
