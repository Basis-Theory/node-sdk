// This file was auto-generated by Fern from our API Definition.

import * as BasisTheory from "../../../src/api/index";
import { BasisTheoryClient } from "../../../src/Client";
import { mockServerPool } from "../../mock-server/MockServerPool";

describe("Sessions", () => {
    test("create (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new BasisTheoryClient({ apiKey: "test", correlationId: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            id: "id",
            type: "type",
            cardBrand: "cardBrand",
            additional_card_brands: ["additional_card_brands"],
            method_url: "method_url",
            method_notification_url: "method_notification_url",
            directory_server_id: "directory_server_id",
            recommended_version: "recommended_version",
            redirect_url: "redirect_url",
        };
        server
            .mockEndpoint()
            .post("/3ds/sessions")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.threeds.sessions.create();
        expect(response).toEqual({
            id: "id",
            type: "type",
            cardBrand: "cardBrand",
            additionalCardBrands: ["additional_card_brands"],
            methodUrl: "method_url",
            methodNotificationUrl: "method_notification_url",
            directoryServerId: "directory_server_id",
            recommendedVersion: "recommended_version",
            redirectUrl: "redirect_url",
        });
    });

    test("create (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new BasisTheoryClient({ apiKey: "test", correlationId: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/3ds/sessions")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.threeds.sessions.create();
        }).rejects.toThrow(BasisTheory.BadRequestError);
    });

    test("create (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new BasisTheoryClient({ apiKey: "test", correlationId: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/3ds/sessions")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.threeds.sessions.create();
        }).rejects.toThrow(BasisTheory.UnauthorizedError);
    });

    test("create (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new BasisTheoryClient({ apiKey: "test", correlationId: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/3ds/sessions")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.threeds.sessions.create();
        }).rejects.toThrow(BasisTheory.ForbiddenError);
    });

    test("get_challenge_result (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new BasisTheoryClient({ apiKey: "test", correlationId: "test", environment: server.baseUrl });

        const rawResponseBody = {
            token_id: "token_id",
            token_intent_id: "token_intent_id",
            session_id: "session_id",
            threeds_version: "threeds_version",
            acs_transaction_id: "acs_transaction_id",
            ds_transaction_id: "ds_transaction_id",
            sdk_transaction_id: "sdk_transaction_id",
            acs_reference_number: "acs_reference_number",
            ds_reference_number: "ds_reference_number",
            liability_shifted: true,
            authentication_value: "authentication_value",
            authentication_status: "authentication_status",
            authentication_status_code: "authentication_status_code",
            directory_status_code: "directory_status_code",
            authentication_status_reason: "authentication_status_reason",
            authentication_status_reason_code: "authentication_status_reason_code",
            eci: "eci",
            acs_challenge_mandated: "acs_challenge_mandated",
            acs_decoupled_authentication: "acs_decoupled_authentication",
            authentication_challenge_type: "authentication_challenge_type",
            acs_rendering_type: { acsInterface: "acsInterface", acsUiTemplate: "acsUiTemplate" },
            acs_signed_content: "acs_signed_content",
            acs_challenge_url: "acs_challenge_url",
            challenge_preference: "challenge_preference",
            challenge_preference_code: "challenge_preference_code",
            challenge_attempts: "challenge_attempts",
            challenge_cancel_reason: "challenge_cancel_reason",
            challenge_cancel_reason_code: "challenge_cancel_reason_code",
            cardholder_info: "cardholder_info",
            whitelist_status: "whitelist_status",
            whitelist_status_source: "whitelist_status_source",
            message_extensions: [{ id: "id", name: "name", critical: true, data: { key: "value" } }],
        };
        server
            .mockEndpoint()
            .get("/3ds/sessions/sessionId/challenge-result")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.threeds.sessions.getChallengeResult("sessionId");
        expect(response).toEqual({
            tokenId: "token_id",
            tokenIntentId: "token_intent_id",
            sessionId: "session_id",
            threedsVersion: "threeds_version",
            acsTransactionId: "acs_transaction_id",
            dsTransactionId: "ds_transaction_id",
            sdkTransactionId: "sdk_transaction_id",
            acsReferenceNumber: "acs_reference_number",
            dsReferenceNumber: "ds_reference_number",
            liabilityShifted: true,
            authenticationValue: "authentication_value",
            authenticationStatus: "authentication_status",
            authenticationStatusCode: "authentication_status_code",
            directoryStatusCode: "directory_status_code",
            authenticationStatusReason: "authentication_status_reason",
            authenticationStatusReasonCode: "authentication_status_reason_code",
            eci: "eci",
            acsChallengeMandated: "acs_challenge_mandated",
            acsDecoupledAuthentication: "acs_decoupled_authentication",
            authenticationChallengeType: "authentication_challenge_type",
            acsRenderingType: {
                acsInterface: "acsInterface",
                acsUiTemplate: "acsUiTemplate",
            },
            acsSignedContent: "acs_signed_content",
            acsChallengeUrl: "acs_challenge_url",
            challengePreference: "challenge_preference",
            challengePreferenceCode: "challenge_preference_code",
            challengeAttempts: "challenge_attempts",
            challengeCancelReason: "challenge_cancel_reason",
            challengeCancelReasonCode: "challenge_cancel_reason_code",
            cardholderInfo: "cardholder_info",
            whitelistStatus: "whitelist_status",
            whitelistStatusSource: "whitelist_status_source",
            messageExtensions: [
                {
                    id: "id",
                    name: "name",
                    critical: true,
                    data: {
                        key: "value",
                    },
                },
            ],
        });
    });

    test("get_challenge_result (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new BasisTheoryClient({ apiKey: "test", correlationId: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/3ds/sessions/sessionId/challenge-result")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.threeds.sessions.getChallengeResult("sessionId");
        }).rejects.toThrow(BasisTheory.UnauthorizedError);
    });

    test("get_challenge_result (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new BasisTheoryClient({ apiKey: "test", correlationId: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/3ds/sessions/sessionId/challenge-result")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.threeds.sessions.getChallengeResult("sessionId");
        }).rejects.toThrow(BasisTheory.ForbiddenError);
    });

    test("get_challenge_result (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new BasisTheoryClient({ apiKey: "test", correlationId: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/3ds/sessions/sessionId/challenge-result")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.threeds.sessions.getChallengeResult("sessionId");
        }).rejects.toThrow(BasisTheory.NotFoundError);
    });

    test("get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new BasisTheoryClient({ apiKey: "test", correlationId: "test", environment: server.baseUrl });

        const rawResponseBody = {
            id: "id",
            type: "type",
            tenant_id: "tenant_id",
            token_id: "token_id",
            token_intent_id: "token_intent_id",
            card_brand: "card_brand",
            additional_card_brands: ["additional_card_brands"],
            expiration_date: "2024-01-15T09:30:00Z",
            created_date: "2024-01-15T09:30:00Z",
            created_by: "created_by",
            modified_date: "2024-01-15T09:30:00Z",
            modified_by: "modified_by",
            device: "device",
            device_info: {
                browser_accept_header: "browser_accept_header",
                browser_ip: "browser_ip",
                browser_javascript_enabled: true,
                browser_java_enabled: true,
                browser_language: "browser_language",
                browser_color_depth: "browser_color_depth",
                browser_screen_height: "browser_screen_height",
                browser_screen_width: "browser_screen_width",
                browser_tz: "browser_tz",
                browser_user_agent: "browser_user_agent",
                sdk_transaction_id: "sdk_transaction_id",
                sdk_application_id: "sdk_application_id",
                sdk_encryption_data: "sdk_encryption_data",
                sdk_ephemeral_public_key: "sdk_ephemeral_public_key",
                sdk_max_timeout: "sdk_max_timeout",
                sdk_reference_number: "sdk_reference_number",
                sdk_render_options: { sdk_interface: "sdk_interface", sdk_ui_type: ["sdk_ui_type"] },
            },
            web_challenge_mode: "web_challenge_mode",
            version: {
                recommended_version: "recommended_version",
                available_versions: ["available_versions"],
                earliest_acs_supported_version: "earliest_acs_supported_version",
                earliest_ds_supported_version: "earliest_ds_supported_version",
                latest_acs_supported_version: "latest_acs_supported_version",
                latest_ds_supported_version: "latest_ds_supported_version",
                acs_information: ["acs_information"],
            },
            method: { method_url: "method_url", method_completion_indicator: "method_completion_indicator" },
            authentication: {
                token_id: "token_id",
                token_intent_id: "token_intent_id",
                session_id: "session_id",
                threeds_version: "threeds_version",
                acs_transaction_id: "acs_transaction_id",
                ds_transaction_id: "ds_transaction_id",
                sdk_transaction_id: "sdk_transaction_id",
                acs_reference_number: "acs_reference_number",
                ds_reference_number: "ds_reference_number",
                liability_shifted: true,
                authentication_value: "authentication_value",
                authentication_status: "authentication_status",
                authentication_status_code: "authentication_status_code",
                directory_status_code: "directory_status_code",
                authentication_status_reason: "authentication_status_reason",
                authentication_status_reason_code: "authentication_status_reason_code",
                eci: "eci",
                acs_challenge_mandated: "acs_challenge_mandated",
                acs_decoupled_authentication: "acs_decoupled_authentication",
                authentication_challenge_type: "authentication_challenge_type",
                acs_rendering_type: { acsInterface: "acsInterface", acsUiTemplate: "acsUiTemplate" },
                acs_signed_content: "acs_signed_content",
                acs_challenge_url: "acs_challenge_url",
                challenge_preference: "challenge_preference",
                challenge_preference_code: "challenge_preference_code",
                challenge_attempts: "challenge_attempts",
                challenge_cancel_reason: "challenge_cancel_reason",
                challenge_cancel_reason_code: "challenge_cancel_reason_code",
                cardholder_info: "cardholder_info",
                whitelist_status: "whitelist_status",
                whitelist_status_source: "whitelist_status_source",
                message_extensions: [{}],
            },
        };
        server.mockEndpoint().get("/3ds/sessions/id").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.threeds.sessions.get("id");
        expect(response).toEqual({
            id: "id",
            type: "type",
            tenantId: "tenant_id",
            tokenId: "token_id",
            tokenIntentId: "token_intent_id",
            cardBrand: "card_brand",
            additionalCardBrands: ["additional_card_brands"],
            expirationDate: new Date("2024-01-15T09:30:00.000Z"),
            createdDate: new Date("2024-01-15T09:30:00.000Z"),
            createdBy: "created_by",
            modifiedDate: new Date("2024-01-15T09:30:00.000Z"),
            modifiedBy: "modified_by",
            device: "device",
            deviceInfo: {
                browserAcceptHeader: "browser_accept_header",
                browserIp: "browser_ip",
                browserJavascriptEnabled: true,
                browserJavaEnabled: true,
                browserLanguage: "browser_language",
                browserColorDepth: "browser_color_depth",
                browserScreenHeight: "browser_screen_height",
                browserScreenWidth: "browser_screen_width",
                browserTz: "browser_tz",
                browserUserAgent: "browser_user_agent",
                sdkTransactionId: "sdk_transaction_id",
                sdkApplicationId: "sdk_application_id",
                sdkEncryptionData: "sdk_encryption_data",
                sdkEphemeralPublicKey: "sdk_ephemeral_public_key",
                sdkMaxTimeout: "sdk_max_timeout",
                sdkReferenceNumber: "sdk_reference_number",
                sdkRenderOptions: {
                    sdkInterface: "sdk_interface",
                    sdkUiType: ["sdk_ui_type"],
                },
            },
            webChallengeMode: "web_challenge_mode",
            version: {
                recommendedVersion: "recommended_version",
                availableVersions: ["available_versions"],
                earliestAcsSupportedVersion: "earliest_acs_supported_version",
                earliestDsSupportedVersion: "earliest_ds_supported_version",
                latestAcsSupportedVersion: "latest_acs_supported_version",
                latestDsSupportedVersion: "latest_ds_supported_version",
                acsInformation: ["acs_information"],
            },
            method: {
                methodUrl: "method_url",
                methodCompletionIndicator: "method_completion_indicator",
            },
            authentication: {
                tokenId: "token_id",
                tokenIntentId: "token_intent_id",
                sessionId: "session_id",
                threedsVersion: "threeds_version",
                acsTransactionId: "acs_transaction_id",
                dsTransactionId: "ds_transaction_id",
                sdkTransactionId: "sdk_transaction_id",
                acsReferenceNumber: "acs_reference_number",
                dsReferenceNumber: "ds_reference_number",
                liabilityShifted: true,
                authenticationValue: "authentication_value",
                authenticationStatus: "authentication_status",
                authenticationStatusCode: "authentication_status_code",
                directoryStatusCode: "directory_status_code",
                authenticationStatusReason: "authentication_status_reason",
                authenticationStatusReasonCode: "authentication_status_reason_code",
                eci: "eci",
                acsChallengeMandated: "acs_challenge_mandated",
                acsDecoupledAuthentication: "acs_decoupled_authentication",
                authenticationChallengeType: "authentication_challenge_type",
                acsRenderingType: {
                    acsInterface: "acsInterface",
                    acsUiTemplate: "acsUiTemplate",
                },
                acsSignedContent: "acs_signed_content",
                acsChallengeUrl: "acs_challenge_url",
                challengePreference: "challenge_preference",
                challengePreferenceCode: "challenge_preference_code",
                challengeAttempts: "challenge_attempts",
                challengeCancelReason: "challenge_cancel_reason",
                challengeCancelReasonCode: "challenge_cancel_reason_code",
                cardholderInfo: "cardholder_info",
                whitelistStatus: "whitelist_status",
                whitelistStatusSource: "whitelist_status_source",
                messageExtensions: [{}],
            },
        });
    });

    test("get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new BasisTheoryClient({ apiKey: "test", correlationId: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server.mockEndpoint().get("/3ds/sessions/id").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.threeds.sessions.get("id");
        }).rejects.toThrow(BasisTheory.UnauthorizedError);
    });

    test("get (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new BasisTheoryClient({ apiKey: "test", correlationId: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/3ds/sessions/id").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.threeds.sessions.get("id");
        }).rejects.toThrow(BasisTheory.NotFoundError);
    });
});
